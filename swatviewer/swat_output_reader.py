"""


@author: Michael Ou

some functions to read output.* generated by SWAT model

"""

import os
import numpy as np
import pandas as pd
from datetime import datetime

def read_cio(lines):
    cio = dict()

    for i, l in enumerate(lines.split('\n')):
        if '|' in l:
            val, key = l.split('|')
            key = key[:key.index(':')].strip()
            cio[key] = val.strip()


    cio['output_start_date'] = pd.Timestamp('{}-01-01'.format(int(cio["IYR"])+int(cio["NYSKIP"]))) + \
                                pd.Timedelta(0 if cio["NYSKIP"]>'0' else int(cio["IDAF"]) - 1, 'D')
    cio['output_end_date']   = pd.Timestamp('{}-01-01'.format(int(cio["IYR"])+int(cio["NBYR"])-1)) + \
                                pd.Timedelta(int(cio["IDAL"]) -1, 'D')
    return cio


def get_hru_header_width(icalen):
    """
    Check ICALEN: Code for printing out calendar or julian dates to .rch, .sub and .hru files
    column names from `header.f`

    Returns
    -------
    column names for output.hru

    """


    columns= [
        "  PRECIPmm"," SNOFALLmm"," SNOMELTmm","     IRRmm",
        "     PETmm","      ETmm"," SW_INITmm","  SW_ENDmm",
        "    PERCmm"," GW_RCHGmm"," DA_RCHGmm","   REVAPmm",
        "  SA_IRRmm","  DA_IRRmm","   SA_STmm","   DA_STmm",
        "SURQ_GENmm","SURQ_CNTmm","   TLOSSmm"," LATQGENmm",
        "    GW_Qmm","    WYLDmm","   DAILYCN"," TMP_AVdgC",
        " TMP_MXdgC"," TMP_MNdgC","SOL_TMPdgC","SOLARMJ/m2",
        "  SYLDt/ha","  USLEt/ha","N_APPkg/ha","P_APPkg/ha",
        "NAUTOkg/ha","PAUTOkg/ha"," NGRZkg/ha"," PGRZkg/ha",
        "NCFRTkg/ha","PCFRTkg/ha","NRAINkg/ha"," NFIXkg/ha",
        " F-MNkg/ha"," A-MNkg/ha"," A-SNkg/ha"," F-MPkg/ha",
        "AO-LPkg/ha"," L-APkg/ha"," A-SPkg/ha"," DNITkg/ha",
        "  NUPkg/ha","  PUPkg/ha"," ORGNkg/ha"," ORGPkg/ha",
        " SEDPkg/ha","NSURQkg/ha","NLATQkg/ha"," NO3Lkg/ha",
        "NO3GWkg/ha"," SOLPkg/ha"," P_GWkg/ha","    W_STRS",
        "  TMP_STRS","    N_STRS","    P_STRS","  BIOMt/ha",
        "       LAI","   YLDt/ha","  BACTPct ","  BACTLPct",
        " WTAB CLIm"," WTAB SOLm","     SNOmm"," CMUPkg/ha",
        "CMTOTkg/ha","   QTILEmm"," TNO3kg/ha"," LNO3kg/ha",
        "  GW_Q_Dmm"," LATQCNTmm"
    ]


    if icalen == 1:
        cols_first = 'LULC HRU GIS SUB MGT MO DA YR AREAkm2'.split()
        widths =     [4,   5,  10, 5,  5,  3, 3, 5, 11]
    else:
        cols_first = 'LULC HRU GIS SUB MGT MON AREAkm2'.split()
        widths =     [4,   5,  10, 5,  5,  5,  11]

    return cols_first + [c.strip() for c in columns], widths + [10] * len(columns)


def get_sub_header_width(icalen):
    """
    Check ICALEN: Code for printing out calendar or julian dates to .rch, .sub and .hru files
    column names from `header.f`

    Returns
    -------
    column names for output.sub

    """


    columns= [
        "  PRECIPmm"," SNOMELTmm","     PETmm","      ETmm",
        "      SWmm","    PERCmm","    SURQmm","    GW_Qmm",
        "    WYLDmm","  SYLDt/ha"," ORGNkg/ha"," ORGPkg/ha",
        "NSURQkg/ha"," SOLPkg/ha"," SEDPkg/ha"," LAT Q(mm)",
        "LATNO3kg/h","GWNO3kg/ha","CHOLAmic/L","CBODU mg/L",
        " DOXQ mg/L"," TNO3kg/ha"
    ]


    if icalen == 1:
        cols_first = 'TYPE SUB      GIS  MO DA  YR   AREAkm2'.split()
        widths = [       6,  5,       9,  4, 3,  4,       11]
    else:
        cols_first = 'TYPE SUB      GIS  MON   AREAkm2'.split()
        widths =     [   6,  5,       9,   5,       11]

    return cols_first + [c.strip() for c in columns], widths + [10] * len(columns)


def get_rch_header_width(icalen):
    """
    Check ICALEN: Code for printing out calendar or julian dates to .rch, .sub and .hru files

    Returns
    -------
    column names for output.rch

    """
    columns= [  "  FLOW_INcms"," FLOW_OUTcms","     EVAPcms",
                "    TLOSScms","  SED_INtons"," SED_OUTtons",
                "SEDCONCmg/kg","   ORGN_INkg","  ORGN_OUTkg",
                "   ORGP_INkg","  ORGP_OUTkg","    NO3_INkg",
                "   NO3_OUTkg","    NH4_INkg","   NH4_OUTkg",
                "    NO2_INkg","   NO2_OUTkg","   MINP_INkg",
                "  MINP_OUTkg","   CHLA_INkg","  CHLA_OUTkg",
                "   CBOD_INkg","  CBOD_OUTkg","  DISOX_INkg",
                " DISOX_OUTkg"," SOLPST_INmg","SOLPST_OUTmg",
                " SORPST_INmg","SORPST_OUTmg","  REACTPSTmg",
                "    VOLPSTmg","  SETTLPSTmg","RESUSP_PSTmg",
                "DIFFUSEPSTmg","REACBEDPSTmg","   BURYPSTmg",
                "   BED_PSTmg"," BACTP_OUTct","BACTLP_OUTct",
                "  CMETAL#1kg","  CMETAL#2kg","  CMETAL#3kg",
                "     TOT Nkg","     TOT Pkg"," NO3ConcMg/l",
                "    WTMPdegc"]

    cols_first = 'TYPE RCH GIS MO DA YR AREAkm2'.split() if icalen == 1 else 'TYPE RCH GIS MON AREAkm2'.split()

    widths = [6, 5, 10, 3, 3, 5, 13] if icalen == 1 else [6, 5, 9, 6, 12]
    return cols_first + [c.strip() for c in columns], widths + [12] * len(columns)


def add_output_index(dat, icalen=1, iprint=0, output_start_date='1990-01-01'):
    """get the datetime index for a SWAT output file

    Args:
        df ([type]): [description]
        icalen (str, optional): [description]. Defaults to 1.
        iprint (str, optional): [description]. Defaults to 0.
        output_start_date (str, optional): [description]. Defaults to '1990-01-01'.
    """


    output_freqs = {'0':'M', '1':'D', '2':'A'}

    icalen = int(icalen)
    iprint = str(iprint)

    if icalen == 1:
        dat.index = dat.apply(lambda x: datetime(x.YR, x.MO, x.DA), axis=1)
    else:
        # TODO: may need to change if the starting date is not Januray 1
        nsub = dat.RCH.max()
        dat = dat[dat.MON <= 366] # remove the annual output
        if iprint == 0: # remove the ending statistics for monthly output
            dat = dat.iloc[:-nsub]

        nperiod = int(dat.shape[0] / nsub) + 1
        date_index = pd.date_range(output_start_date, periods=nperiod, freq=output_freqs[iprint])
        dat.index = np.repeat(date_index, nsub)[:dat.shape[0]]
    
    dat.index.name = 'time'

    return dat

def read_output(f='', ftype='rch', icalen=1, iprint=0, output_start_date='1990-01-01', skiprows=9):
    '''
    read SWAT output reach

    ICALEN: Code for printing out calendar or julian dates to .rch, .sub and .hru files

    Returns
    -------
    dat : TYPE
        DESCRIPTION.

    '''

    #assert os.path.exists(fpath), '{} does not exist. Make sure the model run has completed.'.format(fpath)
    icalen = int(icalen)
    iprint = int(iprint)
    columns, widths = eval(f'get_{ftype}_header_width')(icalen)

    dat = pd.read_fwf(f, skiprows=skiprows, header=None, widths=widths)
    dat.columns = columns
    # print(dat)
    dat = add_output_index(dat, icalen=icalen, iprint=iprint, output_start_date=output_start_date)
    return dat.iloc[:, [1] + list(range(columns.index('AREAkm2'), len(columns)))]



def filter(df_out, units, vars, freq=None, stat=None):
    '''


    Parameters
    ----------
    df_out : TYPE
        the raw dataframe of a SWAT output file
    units : TYPE
        the unit (hru, sub or rch) to be keep.
    vars : TYPE
        the variables to be keep.

    Returns
    -------
    filtered dataframe.

    '''
    unit = df_out.columns[0]
    df_filter = df_out.loc[df_out[unit].isin(units), [unit] + vars]

    if freq is not None:
        # do aggregation
        df_filter = df_filter.groupby(unit).resample(freq).agg({k:v for k, v in zip( vars, stat)})
        df_filter.index.names = [unit, 'time']
    else:
        # reorder to make output consistent with aggreation
        df_filter.index.name = 'time'
        df_filter = df_filter.reset_index().set_index([unit, 'time']).sort_index()

    return df_filter
